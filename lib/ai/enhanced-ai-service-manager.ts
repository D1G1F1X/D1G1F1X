import { getOpenAIClient, getOpenAIAssistant } from "@/lib/openai-assistant"
import { getCardPromptTemplate, getFollowUpPromptTemplate } from "@/lib/ai-prompt-manager"
import type { ReadingRequest } from "@/types/readings"
import type { OracleCard } from "@/types/cards"

/**
 * Generates an oracle reading using the OpenAI Assistant API.
 * @param request The reading request data.
 * @returns The generated reading content as a string.
 */
export async function generateOracleReading(request: ReadingRequest): Promise<string> {
  try {
    const openai = getOpenAIClient()
    const assistant = getOpenAIAssistant()

    // Prepare card details for the prompt
    const cardDetails = request.cards
      .map((card: OracleCard, index: number) => {
        const positionName = request.readingType ? getPositionName(index, request.readingType) : `Card ${index + 1}`
        return `Card ${index + 1} (${positionName}): ${card.fullTitle} (Number: ${card.number}, Suit: ${card.suit}, Base Element: ${card.baseElement}, Synergistic Element: ${card.synergisticElement})`
      })
      .join("\n")

    const questionContext = request.question ? `The seeker's question is: "${request.question}"` : ""

    const prompt = getCardPromptTemplate()
      .replace("{{CARD_COUNT}}", request.cards.length.toString())
      .replace("{{CARD_DETAILS}}", cardDetails)
      .replace("{{QUESTION_CONTEXT}}", questionContext)

    // Create a thread
    const thread = await openai.beta.threads.create()

    // Add a message to the thread
    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: prompt,
    })

    // Run the assistant
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: assistant.id,
    })

    // Poll for the run completion
    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id)
    while (runStatus.status !== "completed") {
      await new Promise((resolve) => setTimeout(resolve, 1000)) // Wait for 1 second
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id)
      if (runStatus.status === "failed" || runStatus.status === "cancelled" || runStatus.status === "expired") {
        throw new Error(`Assistant run failed with status: ${runStatus.status}`)
      }
    }

    // Retrieve messages
    const messages = await openai.beta.threads.messages.list(thread.id)
    const assistantMessages = messages.data.filter((msg) => msg.role === "assistant")

    if (assistantMessages.length > 0) {
      // Assuming the last assistant message contains the reading
      const lastAssistantMessage = assistantMessages[0]
      const textContent = lastAssistantMessage.content.find((content) => content.type === "text")
      if (textContent && textContent.type === "text") {
        return textContent.text.value
      }
    }

    return "No reading could be generated by the AI assistant."
  } catch (error: any) {
    console.error("Error in generateOracleReading:", error)
    throw new Error(`AI reading generation failed: ${error.message || "Unknown error"}`)
  }
}

/**
 * Generates a follow-up response using the OpenAI Assistant API.
 * @param originalReading The content of the original reading.
 * @param followUpQuestion The seeker's follow-up question.
 * @returns The generated follow-up response as a string.
 */
export async function generateFollowUpResponse(originalReading: string, followUpQuestion: string): Promise<string> {
  try {
    const openai = getOpenAIClient()
    const assistant = getOpenAIAssistant()

    const prompt = getFollowUpPromptTemplate()
      .replace("{{ORIGINAL_READING}}", originalReading)
      .replace("{{FOLLOW_UP_QUESTION}}", followUpQuestion)

    // Create a new thread for the follow-up
    const thread = await openai.beta.threads.create()

    // Add the original reading and follow-up question to the thread
    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: prompt,
    })

    // Run the assistant
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: assistant.id,
    })

    // Poll for the run completion
    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id)
    while (runStatus.status !== "completed") {
      await new Promise((resolve) => setTimeout(resolve, 1000)) // Wait for 1 second
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id)
      if (runStatus.status === "failed" || runStatus.status === "cancelled" || runStatus.status === "expired") {
        throw new Error(`Assistant follow-up run failed with status: ${runStatus.status}`)
      }
    }

    // Retrieve messages
    const messages = await openai.beta.threads.messages.list(thread.id)
    const assistantMessages = messages.data.filter((msg) => msg.role === "assistant")

    if (assistantMessages.length > 0) {
      const lastAssistantMessage = assistantMessages[0]
      const textContent = lastAssistantMessage.content.find((content) => content.type === "text")
      if (textContent && textContent.type === "text") {
        return textContent.text.value
      }
    }

    return "No follow-up response could be generated by the AI assistant."
  } catch (error: any) {
    console.error("Error in generateFollowUpResponse:", error)
    throw new Error(`AI follow-up generation failed: ${error.message || "Unknown error"}`)
  }
}

/**
 * Gets the position name based on the index and reading type.
 * This function is duplicated from lib/ai-prompt-manager.ts to avoid circular dependencies
 * if it were imported directly into enhanced-ai-service-manager.ts.
 * @param index The index of the card in the spread.
 * @param readingType The ID of the reading type.
 * @returns The name of the position.
 */
function getPositionName(index: number, readingType: string): string {
  const positions: Record<string, string[]> = {
    singleCard: ["Focus"],
    threeCardPPF: ["Past", "Present", "Future"],
    threeCardMBS: ["Mind", "Body", "Spirit"],
    fiveCardCross: ["Center", "Above", "Below", "Left", "Right"],
    fiveElements: ["Spirit", "Fire", "Water", "Air", "Earth"],
    celticCross: [
      "Present",
      "Challenge",
      "Foundation",
      "Recent Past",
      "Potential",
      "Near Future",
      "Self",
      "Environment",
      "Hopes/Fears",
      "Outcome",
    ],
    relationship: [
      "Seeker",
      "Partner",
      "Past Foundation",
      "Present State",
      "Challenges",
      "Strengths",
      "Lessons",
      "Future Potential",
    ],
    careerPath: [
      "Current Situation",
      "Talents/Strengths",
      "Challenges",
      "Hidden Opportunities",
      "Action Steps",
      "Short-term Outlook",
      "Long-term Potential",
    ],
    spiritualGrowth: [
      "Current State",
      "Spiritual Gifts",
      "Challenges",
      "Soul Lesson",
      "Higher Guidance",
      "Spiritual Practice",
      "Potential Evolution",
    ],
    yearAhead: [
      "Overall Theme",
      "Winter/Q1",
      "Spring/Q2",
      "Summer/Q3",
      "Fall/Q4",
      "Challenges",
      "Opportunities",
      "Spiritual Growth",
      "Practical Advice",
    ],
    decisionMaking: [
      "Current Situation",
      "Option A",
      "Option B",
      "Hidden Factors",
      "Fears/Concerns",
      "Hopes/Desires",
      "Advice",
      "Long-term Impact",
    ],
  }

  const readingPositions = positions[readingType] || Array.from({ length: 10 }, (_, i) => `Position ${i + 1}`)
  return index < readingPositions.length ? readingPositions[index] : `Position ${index + 1}`
}
